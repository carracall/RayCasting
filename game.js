// Generated by CoffeeScript 1.10.0
(function() {
  var Camera, Player, Unitvector, Vector, Wall, backward, c, ctx, forward, interval, keyPressed, left, mainLoop, player, ref, right, setup, walls,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Unitvector = (function() {
    function Unitvector(_x, _y) {
      this._x = _x;
      this._y = _y;
    }

    Unitvector.prototype.dot = function(vec) {
      return this._x * vec._x + this._y * vec._y;
    };

    Unitvector.prototype.cross = function(vec) {
      return this._x * vec._y - this._y * vec._x;
    };

    Unitvector.prototype.rot90 = function() {
      var x;
      x = this.x;
      this.x = -this.y;
      this.y = x;
      return this;
    };

    return Unitvector;

  })();

  Vector = (function(superClass) {
    extend(Vector, superClass);

    function Vector(x, y) {
      this._unit = null;
      this._length = null;
      this._length2 = null;
      Vector.__super__.constructor.call(this, x, y);
    }

    Vector.prototype.len2 = function() {
      if (this._length2 === null) {
        this._length2 = Math.pow(this._x, 2) + Math.pow(this._y, 2);
      }
      return this._length2;
    };

    Vector.prototype.len = function() {
      if (this._length === null) {
        this._length = Math.sqrt(this.len2());
      }
      return this._length;
    };

    Vector.prototype.hat = function() {
      if (!this._unit) {
        this._unit = new Unitvector(this._x / this.len(), this._y / this.len());
      }
      return this._unit;
    };

    Vector.prototype.set = function(_x, _y) {
      this._x = _x;
      this._y = _y;
      this._unit = null;
      this._length = null;
      this._length2 = null;
      return this;
    };

    Vector.prototype.clone = function() {
      return new Vector(this._x, this._y);
    };

    Vector.prototype.cloneAll = function() {
      var a;
      a = new Vector(this._x, this._y);
      a._unit = this._unit;
      a._length = this._length;
      a._length2 = this._length2;
      return a;
    };

    Vector.prototype.add = function(vec) {
      this.set(this._x + vec._x, this._y + vec._y);
      return this;
    };

    Vector.prototype.sub = function(vec) {
      this.set(this._x - vec._x, this._y - vec._y);
      return this;
    };

    Vector.prototype.mult = function(lambda) {
      this.set(this._x * lambda, this._y * lambda);
      return this;
    };

    return Vector;

  })(Unitvector);

  Wall = (function() {
    Wall.h = 1;

    function Wall(x1, y1, x2, y2) {
      this.a = new Vector(x1, y1);
      this.b = new Vector(x2, y2);
    }

    Wall.prototype.getColour = function(b) {
      var c, d, h;
      d = Math.floor(255 * (b / (b + 0.2)));
      h = ["1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
      c = h[Math.floor(d / 16)] + h[d % 16];
      return "rgb(" + c + "," + c + "," + c + ")";
    };

    return Wall;

  })();

  Camera = (function() {
    function Camera(pos, theta1, alpha1, phi1) {
      this.pos = pos;
      this.theta = theta1;
      this.alpha = alpha1;
      this.phi = phi1;
    }

    Camera.prototype._adjust = function() {
      if (this.theta > Math.PI) {
        return this.theta -= 2 * Math.PI;
      } else if (this.theta < -Math.PI) {
        return this.theta += 2 * Math.PI;
      }
    };

    Camera.prototype.drawWalls2 = function(ctx, walls, xres, pixWidth) {
      var _h, brightness, end, i, n, p, rayAng, results, step;
      this._adjust();
      step = this.alpha * 2 / xres;
      rayAng = this.theta - this.alpha;
      end = this.theta + this.alpha;
      i = 0;
      results = [];
      while (rayAng < end) {
        p = this._getIntersection(rayAng, walls);
        if (p !== null) {
          n = closestWall.a.clone().sub(closestWall.b).hat().rot90();
          brightness = Math.abs(p.dot(n) / (p.len2() * p.len()));
          ctx.fillStyle = closestWall.getColour(brightness);
          _h = Math.atan(Wall.h / 2 / p.len()) / this.phi;
          ctx.fillRect(ctx.width - pixWidth * (i + 1), ctx.height / 2 - _h, pixWidth, _h * 2);
        }
        rayAng += step;
        results.push(i += 1);
      }
      return results;
    };

    Camera.prototype.drawWalls = function(ctx, walls, xres, pixWidth, height) {
      var _h, brightness, closestWall, end, i, n, p, rayAng, ref, results, step;
      this._adjust();
      step = this.alpha * 2 / xres;
      rayAng = this.theta + this.alpha;
      end = this.theta - this.alpha;
      i = 0;
      results = [];
      while (rayAng > end) {
        ref = this._getIntersection(rayAng, walls), p = ref[0], closestWall = ref[1];
        if (p !== null) {
          n = closestWall.a.clone().sub(closestWall.b).hat().rot90();
          brightness = Math.abs(p.dot(n) / (p.len2() * p.len()));
          ctx.fillStyle = closestWall.getColour(brightness);
          _h = height * Math.atan(Wall.h / 2 / p.len()) / this.phi;
          ctx.fillRect(i, (height - _h) / 2, 1, _h);
        }
        rayAng -= step;
        results.push(i += 1);
      }
      return results;
    };

    Camera.prototype._getIntersection = function(rayAng, walls) {
      var __a, __b, _a, _b, _p, closestWall, j, len, p, r, t, wall;
      r = new Unitvector(Math.cos(rayAng), Math.sin(rayAng));
      closestWall = null;
      p = null;
      for (j = 0, len = walls.length; j < len; j++) {
        wall = walls[j];
        _a = wall.a.clone().sub(this.pos);
        _b = wall.b.clone().sub(this.pos);
        if (_a.dot(r) > _a.dot(_b.hat()) && _b.dot(r) > _b.dot(_a.hat())) {
          __a = _a.clone();
          __b = _b.clone();
          t = Math.abs((_b.cross(r)) / (_b.sub(_a).cross(r)));
          _p = __a.mult(t).add(__b.mult(1 - t));
          if (p !== null) {
            if (p.len2() > _p.len2()) {
              closestWall = wall;
              p = _p;
            }
          } else {
            p = _p;
            closestWall = wall;
          }
        }
      }
      return [p, closestWall];
    };

    return Camera;

  })();

  Player = (function() {
    function Player(position, theta, alpha, phi) {
      this.position = position;
      this.camera = new Camera(this.position, theta, alpha, phi);
    }

    Player.prototype.moveForward = function(r) {
      return this.position.add(new Vector(Math.cos(this.camera.theta), Math.sin(this.camera.theta)).mult(r));
    };

    Player.prototype.turnLeft = function(dtheta) {
      return this.camera.theta += dtheta;
    };

    return Player;

  })();

  mainLoop = function(ctx, player, walls, width, height) {
    ctx.clearRect(0, 0, width, height);
    return player.camera.drawWalls(ctx, walls, width, 1, height);
  };

  setup = function(canvasID) {
    var canvas, ctx;
    canvas = document.getElementById(canvasID);
    console.log(canvas, canvasID);
    ctx = canvas.getContext("2d");
    return [canvas, ctx];
  };

  walls = [new Wall(2, 0, 3, 3), new Wall(3, 3, 3, -3), new Wall(3, -3, 2, 0)];

  ref = setup("mycanvas"), c = ref[0], ctx = ref[1];

  player = new Player(new Vector(0, 0), 0, Math.PI / 3, Math.PI / 8);

  interval = 1000;

  mainLoop(ctx, player, walls, c.width, c.height);

  console.log("end");

  console.log("saved");

  keyPressed = function(e, c, ctx, walls, player) {
    e = e || window.event;
    console.log("key pressed ", e.keyCode);
    switch (e.keyCode) {
      case '38':
        player.moveForward(0.2);
        console.log("moved forward");
        forward();
        break;
      case '40':
        player.moveForward(-0.2);
        console.log("moved backward");
        break;
      case '37':
        player.turnLeft(Math.PI / 24);
        break;
      case '39':
        player.turnLeft(-Math.PI / 24);
    }
    mainLoop(ctx, player, walls, c.width, c.height);
    return console.log("redrawn");
  };

  backward = function(e) {
    console.log("backward");
    player.moveForward(-0.2);
    return mainLoop(ctx, player, walls, c.width, c.height);
  };

  forward = function(e) {
    console.log("forward");
    player.moveForward(0.2);
    return mainLoop(ctx, player, walls, c.width, c.height);
  };

  left = function(e) {
    console.log("left");
    player.turnLeft(Math.PI / 24);
    return mainLoop(ctx, player, walls, c.width, c.height);
  };

  right = function(e) {
    console.log("right");
    player.turnLeft(-Math.PI / 24);
    return mainLoop(ctx, player, walls, c.width, c.height);
  };

  window.addEventListener("keydown", (function(e) {
    return keyPressed(e, c, ctx, walls, player);
  }), true);

  document.getElementById("back").addEventListener("click", backward);

  document.getElementById("left").addEventListener("click", left);

  document.getElementById("right").addEventListener("click", right);

  document.getElementById("forward").addEventListener("click", forward);

}).call(this);
